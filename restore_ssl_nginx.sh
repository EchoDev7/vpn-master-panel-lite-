#!/bin/bash
# ═══════════════════════════════════════════════════════════
#  restore_ssl_nginx.sh
#  بازسازی کانفیگ Nginx برای دامنه‌ای که cert دارد
#  Usage: sudo bash restore_ssl_nginx.sh <domain> [https_port]
#  Examples:
#    sudo bash restore_ssl_nginx.sh panel.parsiserver.com
#    sudo bash restore_ssl_nginx.sh sub.parsiserver.com 8443
# ═══════════════════════════════════════════════════════════

DOMAIN="${1:-panel.parsiserver.com}"
CONF="/etc/nginx/sites-available/vpn_panel_${DOMAIN}"
LINK="/etc/nginx/sites-enabled/vpn_panel_${DOMAIN}"
CERT_DIR="/etc/letsencrypt/live/${DOMAIN}"
WEBROOT="/var/www/html"
FRONTEND="/opt/vpn-master-panel/frontend/dist"
BACKEND="127.0.0.1:8001"

# Auto-detect HTTPS port: use 8443 if 443 is busy (OpenVPN), else 443
if [ -n "$2" ]; then
    HTTPS_PORT="$2"
else
    if ss -tlnp 2>/dev/null | grep -q ':443 ' || netstat -tlnp 2>/dev/null | grep -q ':443 '; then
        HTTPS_PORT=8443
        echo -e "${YELLOW}⚠ Port 443 is busy (OpenVPN?) — using port 8443 for HTTPS${NC}"
    else
        HTTPS_PORT=443
    fi
fi

# Redirect URL — include port only when non-standard
if [ "$HTTPS_PORT" = "443" ]; then
    REDIRECT_URL="https://\$host\$request_uri"
else
    REDIRECT_URL="https://\$host:${HTTPS_PORT}\$request_uri"
fi

RED='\033[0;31m'; GREEN='\033[0;32m'; YELLOW='\033[1;33m'; CYAN='\033[0;36m'; NC='\033[0m'

echo -e "${CYAN}▶ Restoring Nginx SSL config for: ${DOMAIN}${NC}"

# ── Sanity checks ─────────────────────────────────────────
if [ ! -f "${CERT_DIR}/fullchain.pem" ]; then
    echo -e "${RED}✗ Certificate not found at ${CERT_DIR}/fullchain.pem${NC}"
    echo -e "${YELLOW}  Run: certbot certonly --nginx -d ${DOMAIN}${NC}"
    exit 1
fi

if [ ! -f "/etc/letsencrypt/options-ssl-nginx.conf" ]; then
    echo -e "${YELLOW}⚠ options-ssl-nginx.conf missing — creating fallback...${NC}"
    cat > /etc/letsencrypt/options-ssl-nginx.conf << 'SSLOPT'
ssl_session_cache shared:le_nginx_SSL:10m;
ssl_session_timeout 1440m;
ssl_session_tickets off;
ssl_protocols TLSv1.2 TLSv1.3;
ssl_prefer_server_ciphers off;
ssl_ciphers "ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384";
SSLOPT
fi

if [ ! -f "/etc/letsencrypt/ssl-dhparams.pem" ]; then
    echo -e "${YELLOW}⚠ ssl-dhparams.pem missing — generating (takes ~30s)...${NC}"
    openssl dhparam -out /etc/letsencrypt/ssl-dhparams.pem 2048 2>/dev/null
fi

# ── Write complete Nginx config ───────────────────────────
echo -e "${CYAN}▶ Writing Nginx config to ${CONF}...${NC}"

python3 - << PYEOF
domain      = "${DOMAIN}"
cert_dir    = "${CERT_DIR}"
webroot     = "${WEBROOT}"
frontend    = "${FRONTEND}"
backend     = "${BACKEND}"
conf        = "${CONF}"
https_port  = ${HTTPS_PORT}

redirect_url = f"https://\$host\$request_uri" if https_port == 443 else f"https://\$host:{https_port}\$request_uri"
listen_main  = f"{https_port} ssl http2"

config = f"""# VPN Master Panel — SSL config for {domain}
# HTTPS port: {https_port}  |  Generated by restore_ssl_nginx.sh
# NOTE: {'Port 8443 used because OpenVPN is on port 443.' if https_port == 8443 else 'Port 443 (standard HTTPS).'}

# ── HTTP: ACME renewal + redirect to HTTPS ─────────────────────────────────
server {{
    listen 80;
    listen [::]:80;
    server_name {domain};

    location /.well-known/acme-challenge/ {{
        root {webroot};
        try_files \$uri =404;
    }}

    location / {{
        return 301 {redirect_url};
    }}
}}

# ── HTTPS: main panel (port {https_port}) ──────────────────────────────────
server {{
    listen {listen_main};
    listen [::]:{https_port} ssl http2;
    server_name {domain};

    ssl_certificate     {cert_dir}/fullchain.pem;
    ssl_certificate_key {cert_dir}/privkey.pem;
    include /etc/letsencrypt/options-ssl-nginx.conf;
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;

    add_header Strict-Transport-Security "max-age=15768000; includeSubDomains" always;

    # ── Backend API + SSE streaming ─────────────────────────────────────────
    location /api/ {{
        proxy_pass         http://{backend}/api/;
        proxy_http_version 1.1;
        proxy_set_header   Host              \$host;
        proxy_set_header   X-Real-IP         \$remote_addr;
        proxy_set_header   X-Forwarded-For   \$proxy_add_x_forwarded_for;
        proxy_set_header   X-Forwarded-Proto \$scheme;
        proxy_read_timeout  600s;
        proxy_send_timeout  600s;
        proxy_connect_timeout 30s;
        proxy_buffering    off;
        proxy_cache        off;
        proxy_cache_bypass 1;
        chunked_transfer_encoding on;
        add_header X-Accel-Buffering no always;
    }}

    # ── WebSocket ───────────────────────────────────────────────────────────
    location /ws/ {{
        proxy_pass         http://{backend}/ws/;
        proxy_http_version 1.1;
        proxy_set_header   Upgrade    \$http_upgrade;
        proxy_set_header   Connection "upgrade";
        proxy_set_header   Host       \$host;
        proxy_read_timeout 3600s;
        proxy_send_timeout 3600s;
        proxy_buffering    off;
    }}

    # ── React frontend (static — served by Nginx directly) ──────────────────
    root  {frontend};
    index index.html;

    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff2?)\$ {{
        expires    30d;
        add_header Cache-Control "public, immutable";
        try_files  \$uri =404;
    }}

    location / {{
        try_files \$uri \$uri/ /index.html;
    }}
}}
"""

with open(conf, "w") as f:
    f.write(config)

print(f"Config written OK (HTTPS port: {https_port})")
PYEOF

if [ $? -ne 0 ]; then
    echo -e "${RED}✗ Failed to write config${NC}"
    exit 1
fi

# ── Open firewall port if needed ──────────────────────────
if [ "${HTTPS_PORT}" != "443" ]; then
    ufw allow ${HTTPS_PORT}/tcp > /dev/null 2>&1 && \
        echo -e "${GREEN}✓ Firewall: port ${HTTPS_PORT} opened${NC}"
fi

# ── Enable site ───────────────────────────────────────────
ln -sf "${CONF}" "${LINK}"
echo -e "${GREEN}✓ Symlink created${NC}"

# ── Test and reload ───────────────────────────────────────
echo -e "${CYAN}▶ Testing Nginx config...${NC}"
if nginx -t 2>&1; then
    systemctl reload nginx
    sleep 1
    echo -e "${GREEN}✓ Nginx reloaded successfully${NC}"
    echo ""
    echo -e "${GREEN}═══════════════════════════════════════════════${NC}"
    echo -e "${GREEN}  ✅ Panel is now live at:${NC}"
    if [ "${HTTPS_PORT}" = "443" ]; then
        echo -e "${GREEN}     https://${DOMAIN}${NC}"
    else
        echo -e "${GREEN}     https://${DOMAIN}:${HTTPS_PORT}${NC}"
    fi
    echo -e "${GREEN}═══════════════════════════════════════════════${NC}"
else
    echo -e "${RED}✗ Nginx config test failed — check output above${NC}"
    exit 1
fi

# ── Quick connectivity test ───────────────────────────────
echo ""
echo -e "${CYAN}▶ Connectivity check...${NC}"
HTTP_CODE=$(curl -sk -o /dev/null -w "%{http_code}" "https://${DOMAIN}:${HTTPS_PORT}" 2>/dev/null || echo "unreachable")
echo -e "  https://${DOMAIN}:${HTTPS_PORT} → HTTP ${HTTP_CODE}"

if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "302" ] || [ "$HTTP_CODE" = "301" ]; then
    echo -e "${GREEN}  ✓ Domain is reachable!${NC}"
else
    echo -e "${YELLOW}  ⚠ Got ${HTTP_CODE} — DNS or firewall may need checking${NC}"
    echo -e "${YELLOW}  Try from outside: curl -vk https://${DOMAIN}${NC}"
fi
