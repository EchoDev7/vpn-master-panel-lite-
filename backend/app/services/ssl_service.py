import os
import subprocess
import logging
from typing import Tuple, Optional

logger = logging.getLogger(__name__)

class SSLService:
    def __init__(self):
        self.nginx_conf_dir = "/etc/nginx/sites-available"
        self.certbot_path = "/usr/bin/certbot"
        
    def _run_cmd(self, cmd: str) -> Tuple[bool, str]:
        try:
            result = subprocess.run(
                cmd, shell=True, check=True, 
                stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True
            )
            return True, result.stdout
        except subprocess.CalledProcessError as e:
            logger.error(f"Command failed: {cmd}\nError: {e.stderr}")
            return False, e.stderr

    def stream_letsencrypt_cert(self, domain: str, email: str):
        """
        Generator that yields live Certbot logs for streaming to the frontend.
        """
        if not domain or not email:
            yield "ERROR: Domain and email are required.\n"
            return
            
        yield f"INFO: Initializing Let's Encrypt SSL Request for {domain}...\n"
        
        certbot_path = self.certbot_path
        if not os.path.exists(certbot_path):
             certbot_path = "certbot"
             
        cmd = f"{certbot_path} certonly --non-interactive --agree-tos -m {email} -d {domain} --nginx"
        yield f"EXEC: Running Nginx plugin verification...\n"
        
        process = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
        for line in iter(process.stdout.readline, ""):
            yield f"CERTBOT: {line}"
        process.stdout.close()
        process.wait()
        
        if process.returncode == 0:
             yield f"\nSUCCESS: SSL issued via Nginx plugin!\n"
             yield "EXEC: Generating dynamic Nginx SSL Proxy configuration...\n"
             self._update_nginx_config(domain)
             yield "EXEC: Reloading Nginx...\n"
             subprocess.run("systemctl reload nginx", shell=True)
             yield "DONE: Web server restored. Panel is securely protected.\n"
             return
             
        yield f"\nWARN: Nginx plugin failed (Exit Code: {process.returncode}).\n"
        yield "INFO: Attempting aggressive Standalone fallback mode...\n"
        yield "EXEC: Stopping Nginx service temporarily on port 80...\n"
        subprocess.run("systemctl stop nginx", shell=True)
        
        cmd_fallback = f"{certbot_path} certonly --standalone --non-interactive --agree-tos -m {email} -d {domain}"
        yield f"EXEC: Running Standalone plugin verification...\n"
        
        process2 = subprocess.Popen(cmd_fallback, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
        for line in iter(process2.stdout.readline, ""):
            yield f"CERTBOT: {line}"
        process2.stdout.close()
        process2.wait()
        
        yield "EXEC: Starting Nginx service back up...\n"
        subprocess.run("systemctl start nginx", shell=True)
        
        if process2.returncode == 0:
             yield f"\nSUCCESS: SSL issued via Standalone mode!\n"
             yield "EXEC: Generating dynamic Nginx SSL Proxy configuration...\n"
             self._update_nginx_config(domain)
             yield "EXEC: Restoring Nginx...\n"
             subprocess.run("systemctl start nginx", shell=True)
             yield "DONE: Web server restored. Panel is securely protected.\n"
        else:
             yield f"\nERROR: Certbot standalone request failed (Exit Code: {process2.returncode}).\n"
             yield "FATAL: Please check your domain DNS records and ensure Port 80 is strictly open.\n"

    def _update_nginx_config(self, domain: str):
        """Generates an Nginx config for the panel to enforce HTTPS and route traffic"""
        config_path = f"/etc/nginx/sites-available/vpn_panel_{domain}"
        symlink_path = f"/etc/nginx/sites-enabled/vpn_panel_{domain}"
        
        nginx_conf = f"""
# Auto-generated by VPN Master Panel
server {{
    listen 80;
    server_name {domain};
    return 301 https://$host$request_uri;
}}

server {{
    listen 443 ssl http2;
    server_name {domain};

    ssl_certificate /etc/letsencrypt/live/{domain}/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/{domain}/privkey.pem;
    
    # Modern SSL configuration
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;

    # Route Frontend Panel (React) - Assuming default port 3000 mapping
    location / {{
        proxy_pass http://127.0.0.1:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }}

    # Route Backend API - Assuming default port 8000 mapping
    location /api/ {{
        proxy_pass http://127.0.0.1:8000/api/;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }}
}}
"""
        # Save to file
        try:
            with open(config_path, "w") as f:
                f.write(nginx_conf)
                
            # Create symlink if it doesn't exist
            if not os.path.exists(symlink_path):
                os.symlink(config_path, symlink_path)
        except PermissionError:
            logger.error("Permission denied when writing Nginx config. Must be run as root.")
        except Exception as e:
            logger.error(f"Error generating Nginx config: {e}")
