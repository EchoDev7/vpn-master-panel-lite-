import os
import re
import subprocess
import logging
from typing import Tuple, Optional

logger = logging.getLogger(__name__)

# Strict allow-lists to prevent command injection
_DOMAIN_RE = re.compile(r'^[a-zA-Z0-9][a-zA-Z0-9\-\.]{1,253}[a-zA-Z0-9]$')
_EMAIL_RE  = re.compile(r'^[a-zA-Z0-9._%+\-]+@[a-zA-Z0-9.\-]+\.[a-zA-Z]{2,}$')


class SSLService:
    def __init__(self):
        self.nginx_conf_dir = "/etc/nginx/sites-available"
        self.certbot_path = "/usr/bin/certbot"

    @staticmethod
    def _validate_domain(domain: str) -> bool:
        return bool(domain and _DOMAIN_RE.match(domain))

    @staticmethod
    def _validate_email(email: str) -> bool:
        return bool(email and _EMAIL_RE.match(email))

    def _run_cmd(self, cmd: list) -> Tuple[bool, str]:
        """Run a command safely (no shell=True)."""
        try:
            result = subprocess.run(
                cmd, shell=False, check=True,
                stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True
            )
            return True, result.stdout
        except subprocess.CalledProcessError as e:
            logger.error(f"Command failed: {cmd}\nError: {e.stderr}")
            return False, e.stderr

    def stream_letsencrypt_cert(self, domain: str, email: str):
        """
        Generator that yields live Certbot logs for streaming to the frontend.
        Uses shell=False throughout to prevent command injection.
        """
        if not domain or not email:
            yield "ERROR: Domain and email are required.\n"
            return

        if not self._validate_domain(domain):
            yield "ERROR: Invalid domain name.\n"
            return

        if not self._validate_email(email):
            yield "ERROR: Invalid email address.\n"
            return

        yield f"INFO: Initializing Let's Encrypt SSL Request for {domain}...\n"

        certbot_path = self.certbot_path if os.path.exists(self.certbot_path) else "certbot"

        # Build command as list â€” no shell interpolation possible
        cmd = [
            certbot_path, "certonly",
            "--non-interactive", "--agree-tos",
            "-m", email,
            "-d", domain,
            "--nginx"
        ]
        yield "EXEC: Running Nginx plugin verification...\n"

        process = subprocess.Popen(
            cmd, shell=False,
            stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True
        )
        for line in iter(process.stdout.readline, ""):
            yield f"CERTBOT: {line}"
        process.stdout.close()
        process.wait()

        if process.returncode == 0:
            yield "\nSUCCESS: SSL issued via Nginx plugin!\n"
            yield "EXEC: Generating dynamic Nginx SSL Proxy configuration...\n"
            self._update_nginx_config(domain)
            yield "EXEC: Reloading Nginx...\n"
            subprocess.run(["systemctl", "reload", "nginx"], shell=False)
            yield "DONE: Web server restored. Panel is securely protected.\n"
            return

        yield f"\nWARN: Nginx plugin failed (Exit Code: {process.returncode}).\n"
        yield "INFO: Attempting aggressive Standalone fallback mode...\n"
        yield "EXEC: Stopping Nginx service temporarily on port 80...\n"
        subprocess.run(["systemctl", "stop", "nginx"], shell=False)

        cmd_fallback = [
            certbot_path, "certonly",
            "--standalone", "--non-interactive", "--agree-tos",
            "-m", email,
            "-d", domain
        ]
        yield "EXEC: Running Standalone plugin verification...\n"

        process2 = subprocess.Popen(
            cmd_fallback, shell=False,
            stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True
        )
        for line in iter(process2.stdout.readline, ""):
            yield f"CERTBOT: {line}"
        process2.stdout.close()
        process2.wait()

        yield "EXEC: Starting Nginx service back up...\n"
        subprocess.run(["systemctl", "start", "nginx"], shell=False)

        if process2.returncode == 0:
            yield "\nSUCCESS: SSL issued via Standalone mode!\n"
            yield "EXEC: Generating dynamic Nginx SSL Proxy configuration...\n"
            self._update_nginx_config(domain)
            yield "EXEC: Restoring Nginx...\n"
            subprocess.run(["systemctl", "start", "nginx"], shell=False)
            yield "DONE: Web server restored. Panel is securely protected.\n"
        else:
            yield f"\nERROR: Certbot standalone request failed (Exit Code: {process2.returncode}).\n"
            yield "FATAL: Please check your domain DNS records and ensure Port 80 is strictly open.\n"

    def _update_nginx_config(self, domain: str):
        """Generates an Nginx config for the panel to enforce HTTPS and route traffic"""
        config_path = f"/etc/nginx/sites-available/vpn_panel_{domain}"
        symlink_path = f"/etc/nginx/sites-enabled/vpn_panel_{domain}"
        
        nginx_conf = f"""
# Auto-generated by VPN Master Panel
server {{
    listen 80;
    server_name {domain};
    return 301 https://$host$request_uri;
}}

server {{
    listen 443 ssl http2;
    server_name {domain};

    ssl_certificate /etc/letsencrypt/live/{domain}/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/{domain}/privkey.pem;
    
    # Modern SSL configuration
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;

    # Route Frontend Panel (React) - Assuming default port 3000 mapping
    location / {{
        proxy_pass http://127.0.0.1:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }}

    # Route Backend API - Assuming default port 8000 mapping
    location /api/ {{
        proxy_pass http://127.0.0.1:8000/api/;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }}
}}
"""
        # Save to file
        try:
            with open(config_path, "w") as f:
                f.write(nginx_conf)
                
            # Create symlink if it doesn't exist
            if not os.path.exists(symlink_path):
                os.symlink(config_path, symlink_path)
        except PermissionError:
            logger.error("Permission denied when writing Nginx config. Must be run as root.")
        except Exception as e:
            logger.error(f"Error generating Nginx config: {e}")
